/*******************************************************************************
 * Copyright (c) 2010-2016, Abel Hegedus, IncQuery Labs Ltd.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Abel Hegedus - initial API and implementation
 *******************************************************************************/
package org.eclipse.viatra.query.runtime.extensibility;

import java.util.Collection;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.Platform;
import org.eclipse.viatra.query.runtime.IExtensions;
import org.eclipse.viatra.query.runtime.api.IQueryGroup;
import org.eclipse.viatra.query.runtime.api.IQuerySpecification;
import org.eclipse.viatra.query.runtime.util.ViatraQueryLoggingUtil;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;

/**
 * Loader for the {@link QuerySpecificationRegistry} based on the query group extensions generated by the VIATRA Query
 * builder. The loader has a single instance that processes the extensions on demand if the platform is running, caches
 * the results and updates the {@link QuerySpecificationRegistry}. Note that the loader does not perform class loading
 * on the query group if possible.
 * 
 * <p>
 * The class has a single instance accessible with {@link #getInstance()}.
 * 
 * @author Abel Hegedus
 * @since 1.3
 *
 */
public class ExtensionBasedQuerySpecificationLoader {

    private static final String DUPLICATE_QUERY_GROUP_MESSAGE = "Duplicate query group identifier %s for plugin %s (already contributed by %s)";

    private static final ExtensionBasedQuerySpecificationLoader INSTANCE = new ExtensionBasedQuerySpecificationLoader();
    
    private Multimap<String, String>  contributingPluginOfGroupMap = HashMultimap.create();
    private Map<String, QueryGroupProvider> contributedQueryGroups;
    
    /**
     * @return the single instance of the loader.
     */
    public static ExtensionBasedQuerySpecificationLoader getInstance() {
        return INSTANCE;
    }
    
    /**
     * Loads the query specifications that are registered through extension points into the
     * {@link QuerySpecificationRegistry}.
     */
    public void loadRegisteredQuerySpecificationsIntoRegistry() {
        Map<String, QueryGroupProvider> queryGroupIdToProviderMap = getRegisteredQueryGroups();
        QuerySpecificationRegistry registry = QuerySpecificationRegistry.getInstance();
        for (QueryGroupProvider provider : queryGroupIdToProviderMap.values()) {
            Set<String> querySpecificationFQNs = provider.getQuerySpecificationFQNs();
            if(querySpecificationFQNs.isEmpty()){
                // either the group is empty or the extension was not regenerated to include FQNs
                Set<IQuerySpecification<?>> specifications = provider.get().getSpecifications();
                for (IQuerySpecification<?> specification : specifications) {
                    registry.addQuerySpecification(specification);
                }
            } else {
                // delay specification class loading
                for (IQuerySpecificationProvider specificationProvider : provider.getQuerySpecificationProviders()) {
                    registry.addQuerySpecification(specificationProvider);
                }
            }
        }
        
    }

    private Map<String, QueryGroupProvider> getRegisteredQueryGroups() {
        if(contributedQueryGroups != null) {
            return contributedQueryGroups;
        }
        contributedQueryGroups = Maps.newHashMap();
        if (Platform.isRunning()) {
            final Iterable<IConfigurationElement> config = ImmutableList.<IConfigurationElement> builder()
                    .add(Platform.getExtensionRegistry().getConfigurationElementsFor(IExtensions.QUERY_SPECIFICATION_EXTENSION_POINT_ID))
                    .build();
            for (IConfigurationElement e : config) {
                if (e.isValid()) {
                    processExtension(e);
                }
            }
        }
        return contributedQueryGroups;
    }
    
    private void processExtension(IConfigurationElement el) {
        String id = null;
        try {
            String contributorName = el.getContributor().getName();
            id = el.getAttribute("id");
            if(id == null) {
                throw new IllegalStateException(String.format("Query group extension identifier is required (plug-in: %s)!", contributorName));
            }
            
            QueryGroupProvider provider = new QueryGroupProvider(el);
            
            QueryGroupProvider queryGroupInMap = contributedQueryGroups.get(id);
            if(queryGroupInMap != null) {
                Collection<String> contributorPlugins = contributingPluginOfGroupMap.get(id);
                throw new IllegalStateException(String.format(DUPLICATE_QUERY_GROUP_MESSAGE, id, contributorName, contributorPlugins));
            }
            
            contributedQueryGroups.put(id, provider);
            contributingPluginOfGroupMap.put(id, contributorName);
        } catch (Throwable e) {
            // If there are serious compilation errors in the file loaded by the query registry, an error is thrown
            if (id == null) {
                id = "undefined in plugin.xml";
            }
            ViatraQueryLoggingUtil.getLogger(ExtensionBasedQuerySpecificationLoader.class).error(
                    "[ExtensionBasedQuerySpecificationLoader] Exception during query specification registry initialization when preparing group: "
                            + id + "! " + e.getMessage(), e);
        }
    }

    /**
     * Provider implementation that uses the group extension to load the query group on-demand.
     * It also provides the set of query FQNs that are part of the group without class loading.
     * Once loaded, the query group is cached for future use.
     * 
     * @author Abel Hegedus
     */
    private static final class QueryGroupProvider implements IQueryGroupProvider {
    
        private static final String DUPLICATE_FQN_MESSAGE = "Duplicate FQN %s in query group extension point (plug-in %s)";
        private final IConfigurationElement element;
        private IQueryGroup queryGroup;
        private Set<String> querySpecificationFQNs;
        private Set<IQuerySpecificationProvider> querySpecifications;
        
        public QueryGroupProvider(IConfigurationElement element) {
            this.element = element;
            this.queryGroup = null;
            this.querySpecificationFQNs = null;
            this.querySpecifications = null;
        }
        
        @Override
        public IQueryGroup get() {
            try{
                if(queryGroup == null) {
                    queryGroup = (IQueryGroup) element.createExecutableExtension("group");
                }
                return queryGroup;
            } catch (CoreException e) {
                throw new IllegalArgumentException("Error initializing query group", e);
            }
        }
        
        @Override
        public Set<String> getQuerySpecificationFQNs() {
            if(querySpecificationFQNs == null) {
                querySpecificationFQNs = Sets.newHashSet();
                final Iterable<IConfigurationElement> config = ImmutableList.<IConfigurationElement> builder()
                        .add(element.getChildren("query-specification"))
                        .build();
                for (IConfigurationElement e : config) {
                    if (e.isValid()) {
                        String fqn = e.getAttribute("fqn");
                        boolean added = querySpecificationFQNs.add(fqn);
                        if(!added) {
                            String contributorName = e.getContributor().getName();
                            throw new IllegalArgumentException(String.format(DUPLICATE_FQN_MESSAGE,fqn, contributorName));
                        }
                    }
                }
            }
            return querySpecificationFQNs;
        }
        
        public Set<IQuerySpecificationProvider> getQuerySpecificationProviders() {
            if(querySpecifications == null){
                querySpecifications = Sets.newHashSet();
                Set<String> fqns = getQuerySpecificationFQNs();
                for (String fqn : fqns) {
                    querySpecifications.add(new GroupBasedQuerySpecificationProvider(fqn, this));
                }
            }
            return querySpecifications;
        }
    }
    
    /**
     * Provider implementation that uses the query group extension to load a query specification by its FQN. Note that
     * the FQN of the provided query specification is set with the constructor and can be requested without loading the
     * class. Once loaded, the query specification is cached for future use.
     * 
     * @author Abel Hegedus
     *
     */
    private static final class GroupBasedQuerySpecificationProvider implements IQuerySpecificationProvider{

        private String queryFQN;
        private QueryGroupProvider queryGroupProvider;
        private IQuerySpecification<?> specification;

        public GroupBasedQuerySpecificationProvider(String queryFQN, QueryGroupProvider queryGroupProvider) {
            this.queryFQN = queryFQN;
            this.queryGroupProvider = queryGroupProvider;
            this.specification = null;
        }
        
        @Override
        public IQuerySpecification<?> get() {
            if(specification == null) {
                Set<IQuerySpecification<?>> specifications = queryGroupProvider.get().getSpecifications();
                for (IQuerySpecification<?> spec : specifications) {
                    if(spec.getFullyQualifiedName().equals(queryFQN)){
                        this.specification = spec;
                        return this.specification;
                    }
                }
                throw new IllegalStateException(String.format("Could not find query specifition %s in group (plug-in %s)", queryFQN, queryGroupProvider.element.getContributor().getName()));
            }
            return specification;
        }

        @Override
        public String getFullyQualifiedName() {
            return queryFQN;
        }
        
    }
}
